\subsubsection{Motivating the packet sniffing problem}
\{subsubsection}
Bluetooth technology is harder to sniff compared to other wireless protocols such as 802.11 that already have solutions for promiscuous packet sniffing. Because of howthe way Bluetooth works it is harder to tap the communication between two devices. The devices need to pair before real message are being send. Normally you can only see the discovery messages with are used to find out which Bluetooth devices want to be found. Another problem is that Bluetooth devices can choose to stay hidden.
Due to frequency hopping it is hard to keep track of a device and listen to packet exchanged. However with the Ubertooth project it is now possible. To do so 3 parameters need to be known prior to be able to retrieve any information, the Lower Address Part (LAP), the Upper Address Part (UAP) and the clock CLKN that is the upper 26 bits of the CLK27 of the masters clock. The process to find this parameters is explained later on.

\subsubsection{The Ubertooth project}
\label{subsubsec:ubertooth}
Mike Ossman's project  started in 2010 under the name of Ubertooth is dedicated to create and build a open source hardware that is able to follow and sniff Bluetooth communication. The latest release (Ubertooth 1) is capable of sniffing communication by identifying the right address and the right clock. The following sections are explaining how this is done.

%this might not need to be here, but I think it should be somewhere
\subsubsection{The Ubertooth Tools}
\label{subsubsec:ubertooth_tools}
The Ubertooth comes with some tools to help you sniff packets. This is done by the host code which is provided by project. In the host code there are a few functions. The main one is $ubertooth-rx$ this is the tool that we will be using the most. $ubertooth-rx$ is the tool that does all the hard stuff. It listens to all the packets send on the bandwidth and displays them. If you are using the default settings it will try to look for all the UAP of the devices. If you home in on a single device you want to track it will do more. It will then use the address it is following to find the clock and then decrypt the package. This package will then be printed with all the data inside. This is exactly where what we are looking for. There is also a Kismet plug-in available which does the same as $ubertooth-rx$, but displays it in a better way. This also makes it log files in a pcap format which can then be used to analyse in wireshark. 

\subsubsection{Finding the UAP}
\label{subsubsec:finding_uap}
The UAP (Upper Address Part) is the important to do anything interesting with Bluetooth. For instance it used to determine the hopping sequence that is used for the communication between two devices. It is 8 bits of the 48 bits $BD_ADDR$ (Bluetooth Device address). The LAP is transmitted in plaintext so it not hard to find as it is present in all the packets. The First part is the NAP(Non-significant Adresss Part). This part is ignored because it is not needed for the initial communication. Because the UAP is only 8 bits it can be brute forced. This is not a good way to find it. Brute forcing is detectable and it will only work when the master is a connectible state. 
The Ubertooth is made to be a passive sniffer so this method is not used. One of the techniques used to determine the UAP is by using the HEC(Header Error Check). This is used to check if the header is received without errors. With this it is possible to determine what the are the unknown bits which will be the UAP. This header is send with each packet so it makes it easy to decode. The only problem is that it is XOR with a pseudo-random stream. To try and decode this is called "whitening". There are 64 possible streams it will use and this depends on which clock is used. It will then generate 64 candidate UAP with each of the 64 streams. Sometimes the packets will have a CRC that can be use to check if the right stream is used to decode the packet.
Another method is to perform a series of sanity checks on the packet format. The packet type can then be unwhiten. If the packet type is known some information can be derive such as the packet length. These information can confirm or deny a possible match. The problem with this is that false negatives can happen and it can eliminate UAP streams which are valid. This can happen, because the data that is decoded will be of wrong packet type and it will make the wrong conclusion on whether to or throw away this possible clock. This will lead to not finding any UAP for the master and the process will have to be restarted in order to find it.

\subsubsection{Finding the right clock}
