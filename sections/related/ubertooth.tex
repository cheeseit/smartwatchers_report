\subsubsection{Motivating the packet sniffing problem}
Bluetooth technology is harder to sniff compared to other wireless protocols such as 802.11 that already have solutions for promiscuous packet sniffing. Indeed Bluetooth functionment makes it hard to listen to traffic in a promiscuous way.
Indeed due to frequency hopping it is hard to keep track of a device and listen to packet exchanged. However with the Ubertooth project it is now possible. To do so 3 parameters need to be known prior to be able to retrieve any information, the Lower Address Part (LAP), the Upper Address Part (UAP) and the clock CLKN that is the upper 26 bits of the CLK27 of the masters clock. The process to find this parameters is explained later on.

\subsubsection{The Ubertooth project}

Mike Ossman's project  started in 2010 under the name of Ubertooth is dedicated to create and build a open source hardware that is able to fallow and sniff a Bluetooth communication. The latest release (Ubertooth 1) is capable of sniffing communication by identifying the right address and the right clock. The fallowing sections are explaining how this is done.

\subsubsection{Finding the UAP}
The UAP (Upper Address Part) is the important to do anything interesting with Bluetooth. For instance it used to determine the hopping sequence that is used for the communication between two devices. It is 8 bits of the 48 bits $BD_ADDR$ (Bluetooth Device address). The LAP is transmitted in plaintext so it not hard to find as it is present in all the packets. The First part is the NAP(Non-significant Adresss Part). This part is ignored because it is not needed for the initial communication. Because the UAP is only 8 bits it can be brute forced. This is not a good way to find it. Brute forcing is detectable and it will only work when the master is a connectible state. 
The Ubertooth is made to be a passive sniffer so this method is not used. One of the techniques used to determine the UAP is by using the HEC(Header Error Check). This is used to check if the header is received without errors. With this it is possible to determine what the are the unknown bits which will be the UAP. This header is send with each packet so it makes it easy to decode. The only problem is that it is XOR with a pseudo-random stream. To try and decode this is called "whitening". There are 64 possible streams it will use and this depends on which clock is used. It will then generate 64 candidate UAP with each of the 64 streams. Sometimes the packets will have a CRC that can be use to check if the right stream is used to decode the packet.
Another method is to perform a series of sanity checks on the packet format. The packet type can then be unwhiten. If the packet type is known some information can be derive such as the packet length. These information can confirm or deny a possible match. The problem with this is that false negatives can happen and it can eliminate UAP streams which are valid. This can happen, because the data that is decoded will be of wrong packet type and it will make the wrong conclusion on whether to or throw away this possible clock. This will lead to not finding any UAP for the master and the process will have to be restarted in order to find it.

\subsubsection{Finding the right clock}
